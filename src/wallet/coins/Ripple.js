import{RippleAPI}from"ripple-lib";import RippleAddress from"ripple-address-codec";import{AccountType,CoinType}from"../constants";import tradingPlatformConfig from"../config/trading-platform";import rippleKeypairs from"ripple-keypairs";import Big from"big.js";class RippleWallet{constructor(e,t={}){e&&this.setServer(e),this.option=t}setServer(e){this.url=e,this.server&&this.server.isConnected()||(this.server=new RippleAPI({server:e,maxFeeXRP:"0.05",timeout:1e4}))}destroy(){this.server&&this.server.isConnected()&&this.server.disconnect()}getInstance(){return this.server}async isActivated(e){return this.server.isConnected()||await this.server.connect(),new Promise(t=>{this.server.getAccountInfo(e).then(()=>{t(!0)}).catch(e=>{e.data&&"actNotFound"===e.data.error&&t(!1)})})}async getBalances(e){this.server.isConnected()||await this.server.connect();try{let t,r=await this.server.getBalances(e),s=[];r.forEach(e=>{e.currency===CoinType.XRP?t={code:e.currency,value:e.value}:s.push({code:e.currency,value:e.value,issuer:e.counterparty||""})});let i=await this.server.getAccountInfo(e);return t.frozenNative=20+5*i.ownerCount,s.unshift(t),s}catch(e){return console.error(e),[{value:"0",code:CoinType.XRP}]}}async isTrustAsset(e,t,r){if(CoinType.XRP===t&&!r)return!0;if(e&&r&&e===r)return!0;let s=await this.server.getTrustlines(e);return!(!s&&0===s.length)&&s.some(e=>e.specification.counterparty===r&&e.specification.currency===t&&"0"!==e.specification.limit)}getTransactions(e,t={}){return new Promise(async(r,s)=>{try{const i=(await this.server.getServerInfo()).completeLedgers.split("-");let n={minLedgerVersion:Number(i[0]),maxLedgerVersion:Number(i[1])};n={...n,...t},r(await this.server.getTransactions(e,n))}catch(e){console.error(e),s(e)}})}sendTransaction(e,t,r,s={}){const i=rippleKeypairs.deriveKeypair(e),n=rippleKeypairs.deriveAddress(i.publicKey);let a=s.assetCode||CoinType.XRP,o={source:{address:n,maxAmount:{value:r,currency:a}},destination:{address:t,amount:{value:r,currency:a}}};if(s.assetIssuer&&(o.destination.amount.counterparty=s.assetIssuer,o.source.maxAmount.counterparty=s.assetIssuer),""!==s.tag){let e=new Number(s.tag);o.destination.tag=e.valueOf()}return new Promise((t,r)=>{this.server.preparePayment(n,o).then(s=>{const{signedTransaction:i}=this.server.sign(s.txJSON,e);this.server.submit(i).then(e=>{console.info(e),t(e)}).catch(e=>{console.info(e),r(e)})})})}async changeTrust(e,t,r,s){const i=rippleKeypairs.deriveKeypair(e),n=rippleKeypairs.deriveAddress(i.publicKey),a={currency:t,counterparty:r,limit:s,ripplingDisabled:!0};return new Promise((t,r)=>{this.server.prepareTrustline(n,a).then(s=>{const{signedTransaction:i}=this.server.sign(s.txJSON,e);this.server.submit(i).then(e=>{console.info(e),t(e)}).catch(e=>{console.info(e),r(e)})})})}isValidAddress(e){return RippleAddress.isValidAddress(e)}isTradingPlatformAddress(e){return tradingPlatformConfig[AccountType.ripple][e]}getAccount(e){let t={entropy:e};const r=rippleKeypairs.generateSeed(t),s=rippleKeypairs.deriveKeypair(r);return{secret:r,address:rippleKeypairs.deriveAddress(s.publicKey)}}getAccountFromSecret(e){const t=rippleKeypairs.deriveKeypair(e);return{secret:e,address:rippleKeypairs.deriveAddress(t.publicKey)}}async queryBook(e,t){return new Promise(async(r,s)=>{try{const i={base:{currency:e.code},counter:{currency:t.code}};let n="";e.issuer&&(n=e.issuer,i.base.counterparty=e.issuer),t.issuer&&(n||(n=t.issuer),i.counter.counterparty=t.issuer),await this.server.getOrderbook(n,i,{limit:150}).then(e=>{let t={asks:[],bids:[]};e.asks.map(e=>{let r=e.specification.quantity.value,s=Number(new Big(e.specification.totalPrice.value).div(e.specification.quantity.value).toFixed(7).toString()).toString();if(e.state&&(r=e.state.fundedAmount.value),Number(r)===Number(0))return;let i={amount:r,price:s},n=t.asks.pop();n?n.price===i.price?(n.amount=Number(new Big(n.amount).add(i.amount).toFixed(7).toString()).toString(),t.asks.push(n)):(t.asks.push(n),t.asks.push(i)):t.asks.push(i)}),e.bids.map(e=>{let r=e.specification.quantity.value,s=Number(new Big(e.specification.totalPrice.value).div(e.specification.quantity.value).toFixed(7).toString()).toString();if(e.state&&(r=e.state.priceOfFundedAmount.value),Number(r)===Number(0))return;let i={amount:r,price:s},n=t.bids.pop();n?n.price===i.price?(n.amount=Number(new Big(n.amount).add(i.amount).toFixed(7).toString()).toString(),t.bids.push(n)):(t.bids.push(n),t.bids.push(i)):t.bids.push(i)}),r(t)}).catch(e=>{console.error(e),s(e)})}catch(e){s(e)}})}async queryOffers(e,t={}){return new Promise(async(r,s)=>{try{let i={};t.limit?i.limit=t.limit:i.limit=200,r(await this.server.getOrders(e,i))}catch(e){s(e)}})}async sendOffer(e,t,r,s,i,n,a){return new Promise(async(o,c)=>{try{let u=Number(new Big(r).times(s).toString()).toFixed(8).toString();const p={direction:a,quantity:{currency:t.code,value:r},totalPrice:{currency:e.code,value:u},passive:!1,fillOrKill:!1};e.issuer&&(p.totalPrice.counterparty=e.issuer),t.issuer&&(p.quantity.counterparty=t.issuer);let l=await this.server.prepareOrder(i,p);const{signedTransaction:d}=this.server.sign(l.txJSON,n);this.server.submit(d).then(e=>{console.info(e),e&&"tesSUCCESS"===e.resultCode?o(e):c(e.resultMessage)}).catch(e=>{console.info(e),c(e)})}catch(e){c(e)}})}async cancelOffer(e,t,r){return new Promise(async(s,i)=>{try{const n={orderSequence:e.id};let a=await this.server.prepareOrderCancellation(t,n);const{signedTransaction:o}=this.server.sign(a.txJSON,r);this.server.submit(o).then(e=>{console.info(e),e&&"tesSUCCESS"===e.resultCode?s(e):i(e.resultMessage)}).catch(e=>{console.info(e),i(e)})}catch(e){i(e)}})}async queryLastBook(e,t,r={}){return new Promise((s,i)=>{try{let n={limit:1,descending:!0};r.descending=n.descending,r.limit&&(n.limit=r.limit);let a=`https://data.ripple.com/v2/exchanges/${e.code}+${e.issuer}/${t.code}+${t.issuer}?limit=${r.limit}&descending=${r.descending}`;r.forAccount&&(a=`https://data.ripple.com/v2/accounts/${r.forAccount}/exchanges?descending=true&limit=200`);let o=new XMLHttpRequest;o.onreadystatechange=(()=>{4===o.readyState&&200===o.status?s(JSON.parse(o.responseText)):400===o.status&&s({data:[]})}),o.open("GET",a),o.send()}catch(e){i(e)}})}async setAccountInfo(e,t,r){try{this.server.isConnected()||await this.server.connect();let s=await this.server.prepareSettings(e,r),i=this.server.sign(s.txJSON,t);return await this.server.submit(i.signedTransaction)}catch(e){console.log(e)}}queryAccountInfo(e){return new Promise(async(t,r)=>{try{t(await this.server.getSettings(e))}catch(e){r(e)}})}}export default RippleWallet;

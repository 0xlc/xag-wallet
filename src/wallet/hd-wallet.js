let has=require("lodash/has"),bip39=require("bip39"),hdkey=require("ethereumjs-wallet/hdkey"),derivePath=require("ed25519-hd-key").derivePath;import{AccountType}from"./constants";const ENTROPY_BITS=256,INVALID_SEED="Invalid seed (must be a Buffer or hex string)",INVALID_MNEMONIC="Invalid mnemonic (see bip39)";class HDWallet{static fromMnemonic(e,t,r="english"){if(!HDWallet.validateMnemonic(e,r))throw new Error(INVALID_MNEMONIC);return new HDWallet(bip39.mnemonicToSeedHex(e,t))}static fromSeed(e){let t;if(Buffer.isBuffer(e))t=e.toString("hex");else{if("string"!=typeof e)throw new TypeError(INVALID_SEED);t=e}return new HDWallet(t)}static generateMnemonic({entropyBits:e=ENTROPY_BITS,language:t="english",rngFn:r}={}){if(t&&!has(bip39.wordlists,t))throw new TypeError(`Language ${t} does not have a wordlist in the bip39 module`);const n=bip39.wordlists[t];return bip39.generateMnemonic(e,r,n)}static validateMnemonic(e,t="english"){if(t&&!has(bip39.wordlists,t))throw new TypeError(`Language ${t} does not have a wordlist in the bip39 module`);const r=bip39.wordlists[t];return bip39.validateMnemonic(e,r)}constructor(e){this.seedHex=e}getAccount(e,t){let r=e.derive_path.replace("index",t);if(e.name==AccountType.ethereum){let t=hdkey.fromMasterSeed(new Buffer.from(this.seedHex,"hex")).derivePath(r);return e.wallet.getAccount(t)}if(e.name===AccountType.stellar||e.name===AccountType.ripple||e.name===AccountType.ripplexag){let t=derivePath(r,this.seedHex);return e.wallet.getAccount(t.key)}if(e.name===AccountType.bitcoin)return e.wallet.getAccount(this.seedHex,r)}static getAccountFromSecret(e,t){return e.wallet.getAccountFromSecret(t)}}export default HDWallet;
